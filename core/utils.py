import yaml
import sys
import os
import importlib
import logging
# Ajout de l'importation pour l'analyseur IA
from .ai_analyzer import get_ai_analysis

# Configuration du logging
logger = logging.getLogger('iotbreaker')

def log_info(message):
    """Fonction de logging pour les informations"""
    logger.info(message)
    print(f"[+] {message}")

def log_error(message):
    """Fonction de logging pour les erreurs"""
    logger.error(message)
    print(f"[!] ERREUR: {message}")

def log_warning(message):
    """Fonction de logging pour les avertissements"""
    logger.warning(message)
    print(f"[!] AVERTISSEMENT: {message}")

# Import dynamique pour √©viter les imports circulaires
def get_module(module_name):
    """Import dynamique d'un module pour √©viter les imports circulaires"""
    return importlib.import_module(f'core.{module_name}')

def run_script_yaml(path, ai_driven_mode=False):
    """
    Ex√©cute un sc√©nario de test √† partir d'un fichier YAML.
    
    En mode 'ai_driven_mode', l'IA choisit les prochaines √©tapes
    en fonction des r√©sultats obtenus.
    
    Le format attendu est:
    ```yaml
    name: Nom du sc√©nario
    description: Description du sc√©nario (optionnel)
    steps:
      - type: discover|analyze|check
        target: IP_CIBLE (optionnel pour discover)
        description: Description de l'√©tape (optionnel)
    config:
      timeout: 5  # Timeout en secondes
      verbose: true  # Mode verbeux
      safe_mode: true  # Mode sans impact
    """
    
    # Configuration automatique de la cl√© API Shodan
    try:
        from .shodan_analyzer import set_api_key
        # Utilise uniquement les variables d'environnement pour la s√©curit√©
        shodan_key = os.getenv('SHODAN_API_KEY')
        if shodan_key:
            set_api_key(shodan_key)
            print(f"[+] Cl√© API Shodan configur√©e via variable d'environnement")
        else:
            print(f"[!] Cl√© API Shodan non trouv√©e. D√©finissez SHODAN_API_KEY dans vos variables d'environnement")
    except ImportError:
        pass
    
    if not os.path.exists(path):
        print(f"[!] ERREUR: Le fichier de sc√©nario '{path}' n'existe pas.")
        sys.exit(1)

    print(f"[*] Chargement du sc√©nario : {path}")
    try:
        with open(path, "r") as f:
            data = yaml.safe_load(f)
    except yaml.YAMLError as e:
        print(f"[!] ERREUR: Format YAML invalide: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"[!] ERREUR: Impossible de lire le fichier: {e}")
        sys.exit(1)

    # Validation du format du sc√©nario
    if not isinstance(data, dict):
        print("[!] ERREUR: Format du sc√©nario invalide. Le fichier YAML doit contenir un dictionnaire.")
        sys.exit(1)
    
    if "steps" not in data or not isinstance(data["steps"], list):
        print("[!] ERREUR: Le sc√©nario doit contenir une liste 'steps'.")
        sys.exit(1)
    
    # Affichage des informations du sc√©nario
    print(f"[+] Ex√©cution du sc√©nario: {data.get('name', 'Sans nom')}")
    if "description" in data:
        print(f"[+] Description: {data['description']}")
    
    # Configuration
    config = data.get("config", {})
    timeout = config.get("timeout", 5)
    verbose = config.get("verbose", False)
    safe_mode = config.get("safe_mode", True)
    should_exploit = config.get("exploit", False)
    if should_exploit:
        print("[!] Mode exploitation activ√©. Des actions actives seront tent√©es sur les cibles.")
    print(f"[+] Configuration: timeout={timeout}s, verbose={verbose}, safe_mode={safe_mode}")
    
    # On initialise une liste pour stocker tous les r√©sultats de l'audit
    all_results = []
    
    # Variables pour la d√©couverte automatique
    discovered_devices = []
    auto_discovery_enabled = config.get("auto_discovery", False)
    
    # ----- NOUVELLE LOGIQUE POUR LE MODE PILOT√â PAR L'IA -----
    if ai_driven_mode:
        print("[üß†] Mode d'audit pilot√© par l'IA activ√©. L'IA d√©cidera des prochaines actions.")
        
        # L'√©tat de l'audit, que nous fournirons √† l'IA
        audit_context = {
            "scenario_name": data.get('name', 'Audit Dynamique'),
            "devices_found": [],
            "vulnerabilities_found": [],
            "history": []
        }

        # On commence par une √©tape de d√©couverte, qui est toujours n√©cessaire
        print("\n[*] √âtape 1 (forc√©e): D√©couverte des appareils...")
        discovered_devices = get_module("discover").run()
        audit_context["devices_found"] = [d['ip'] for d in discovered_devices if 'ip' in d]
        audit_context["history"].append("D√©couverte r√©seau effectu√©e.")

        # Boucle d'audit dynamique pilot√©e par l'IA
        for i in range(2, 10): # On limite √† 10 √©tapes pour √©viter les boucles infinies
            prompt_ai = f"""
            Contexte de l'audit de s√©curit√© IoT en cours :
            - Sc√©nario: {audit_context['scenario_name']}
            - Appareils d√©couverts: {audit_context['devices_found']}
            - Vuln√©rabilit√©s d√©j√† trouv√©es: {audit_context['vulnerabilities_found']}
            - Historique des actions: {audit_context['history']}

            En te basant sur ce contexte, quelle est la prochaine √©tape la plus logique ? Choisis UNE seule action parmi les suivantes :
            - "ANALYZE <IP>" (pour scanner les ports d'un appareil)
            - "CHECK <IP>" (pour chercher des vuln√©rabilit√©s sur un appareil)
            - "SHODAN_LOOKUP <IP>" (pour obtenir des infos sur une IP publique)
            - "STOP" (si tu estimes que l'audit est termin√© ou qu'il n'y a plus rien de pertinent √† faire)

            R√©ponds uniquement avec l'action choisie. Par exemple : "CHECK 192.168.1.50"
            """

            print(f"\n[üß†] L'IA r√©fl√©chit √† l'√©tape {i}...")
            next_action = get_ai_analysis(prompt_ai, max_length=64)
            
            print(f"  [+] D√©cision de l'IA : {next_action}")
            audit_context["history"].append(f"D√©cision IA: {next_action}")
            
            action_parts = next_action.split()
            command = action_parts[0].lower()
            target = action_parts[1] if len(action_parts) > 1 else None

            if command == "stop":
                print("[+] L'IA a d√©cid√© de terminer l'audit.")
                break
            
            if not target:
                print("[!] L'IA n'a pas sp√©cifi√© de cible. Arr√™t de l'audit.")
                break

            # Ex√©cution de l'action choisie par l'IA
            if command == "analyze":
                get_module("analyze").run(target)
            elif command == "check":
                results_from_check = get_module("check").run(target)
                if results_from_check:
                    all_results.extend(results_from_check)
                    audit_context["vulnerabilities_found"].extend(results_from_check)
            elif command == "shodan_lookup":
                shodan_result = get_module("shodan_analyzer").get_info_for_ip(target)
                if shodan_result:
                    all_results.append(shodan_result)
            else:
                print(f"[!] Commande de l'IA inconnue : '{command}'. Arr√™t.")
                break
                
    else:
        # ----- LOGIQUE EXISTANTE POUR LE MODE SCRIPT√â -----
        print("[+] Mode d'audit script√© classique activ√©.")
        
        # Ex√©cution des √©tapes
        print("\n[*] D√©but de l'ex√©cution des √©tapes...")
        
        for i, step in enumerate(data.get("steps", []), 1):
            if not isinstance(step, dict) or "type" not in step:
                print(f"[!] AVERTISSEMENT: L'√©tape {i} est mal format√©e, ignor√©e.")
                continue
            
            step_type = step.get("type")
            target = step.get("target", "")
            description = step.get("description", "")
            
            print(f"\n[*] √âtape {i}: {step_type} {target} {description}")
            
            if step_type == "discover":
                discovered_devices = get_module("discover").run()
                if discovered_devices and auto_discovery_enabled:
                    print(f"[+] {len(discovered_devices)} appareils d√©couverts pour l'audit automatique")
            elif step_type == "analyze":
                if target == "auto_discovered" and discovered_devices:
                    # Analyse automatique de tous les appareils d√©couverts
                    analyze_module = get_module("analyze")
                    for device in discovered_devices:
                        device_ip = device.get('ip', '')
                        if device_ip:
                            print(f"[*] Analyse automatique de {device_ip}")
                            analyze_module.run(device_ip)
                elif target and target != "auto_discovered":
                    analyze_module = get_module("analyze")
                    analyze_module.run(target)
                else:
                    print("[!] AVERTISSEMENT: Aucune cible sp√©cifi√©e pour l'analyse.")
            elif step_type == "check":
                if target == "auto_discovered" and discovered_devices:
                    # V√©rification automatique de tous les appareils d√©couverts
                    check_module = get_module("check")
                    for device in discovered_devices:
                        device_ip = device.get('ip', '')
                        if device_ip:
                            print(f"[*] V√©rification automatique de {device_ip}")
                            results_from_check = check_module.run(device_ip)
                            if results_from_check:
                                # Exploit Telnet si demand√©
                                for vuln in results_from_check:
                                    if should_exploit and vuln.get('severity') == 'CRITICAL' and vuln.get('module') == 'Telnet':
                                        try:
                                            creds = vuln['description'].split(': ')[-1].split(':')
                                            user, passwd = creds[0], creds[1]
                                            exploit_module = get_module("exploit")
                                            exploit_module.exploit_telnet(device_ip, user, passwd)
                                        except Exception:
                                            print(f"[!] Impossible d'extraire les identifiants pour l'exploit Telnet.")
                                    # Exploit MQTT si demand√©
                                    if should_exploit and 'MQTT' in vuln.get('module', '') and "abonnement √† tous les topics" in vuln.get('description', ''):
                                        exploit_module = get_module("exploit")
                                        exploit_module.exploit_mqtt(device_ip)
                                all_results.extend(results_from_check)
                elif target and target != "auto_discovered":
                    check_module = get_module("check")
                    results_from_check = check_module.run(target)
                    if results_from_check:
                        # Exploit Telnet si demand√©
                        for vuln in results_from_check:
                            if should_exploit and vuln.get('severity') == 'CRITICAL' and vuln.get('module') == 'Telnet':
                                try:
                                    creds = vuln['description'].split(': ')[-1].split(':')
                                    user, passwd = creds[0], creds[1]
                                    exploit_module = get_module("exploit")
                                    exploit_module.exploit_telnet(target, user, passwd)
                                except Exception:
                                    print(f"[!] Impossible d'extraire les identifiants pour l'exploit Telnet.")
                            # Exploit MQTT si demand√©
                            if should_exploit and 'MQTT' in vuln.get('module', '') and "abonnement √† tous les topics" in vuln.get('description', ''):
                                exploit_module = get_module("exploit")
                                exploit_module.exploit_mqtt(target)
                        all_results.extend(results_from_check)
                else:
                    print("[!] AVERTISSEMENT: Aucune cible sp√©cifi√©e pour la v√©rification.")
            elif step_type == "analyze_firmware":
                firmware_file = step.get("file")
                if not firmware_file:
                    print("[!] AVERTISSEMENT: L'√©tape analyze_firmware n√©cessite un fichier 'file'.")
                    continue
                firmware_analyzer_module = get_module("firmware_analyzer")
                firmware_analyzer_module.analyze_firmware(firmware_file)
            elif step_type == "shodan_lookup":
                target = step.get("target")
                if not target:
                    print("[!] AVERTISSEMENT: L'√©tape shodan_lookup n√©cessite une cible 'target'.")
                    continue
                
                # Gestion de l'IP publique automatique
                if target == "auto_public_ip":
                    try:
                        import requests
                        response = requests.get('https://api.ipify.org', timeout=5)
                        target = response.text
                        print(f"[*] IP publique d√©tect√©e automatiquement: {target}")
                    except Exception as e:
                        print(f"[!] Impossible de r√©cup√©rer l'IP publique: {e}")
                        continue
                
                shodan_analyzer_module = get_module("shodan_analyzer")
                shodan_result = shodan_analyzer_module.get_info_for_ip(target)
                if shodan_result:
                    all_results.append(shodan_result)
            elif step_type == "shodan_search":
                query = step.get("query")
                limit = step.get("limit", 10)
                if not query:
                    print("[!] AVERTISSEMENT: L'√©tape shodan_search n√©cessite une requ√™te 'query'.")
                    continue
                shodan_analyzer_module = get_module("shodan_analyzer")
                shodan_analyzer_module.search_devices(query, limit)
            else:
                print(f"[!] AVERTISSEMENT: Type d'√©tape inconnu : {step_type}")
    
    print("\n[+] Ex√©cution du sc√©nario termin√©e.")
    
    # Ajout du r√©sum√© d'ex√©cution pour le reporting
    try:
        from .reporting import add_execution_summary
        add_execution_summary("Sc√©nario ex√©cut√©", data.get('name', 'Sans nom'))
        add_execution_summary("Nombre d'√©tapes", len(data.get("steps", [])))
        add_execution_summary("Vuln√©rabilit√©s trouv√©es", len(all_results))
        add_execution_summary("Mode exploitation", "Activ√©" if should_exploit else "D√©sactiv√©")
        add_execution_summary("Mode s√©curis√©", "Activ√©" if safe_mode else "D√©sactiv√©")
        add_execution_summary("Timeout configur√©", f"{timeout} secondes")
    except ImportError:
        pass
    
    # On appelle les g√©n√©rateurs de rapport
    scenario_title = data.get('name', 'Sans nom')
    reporting_module = get_module("reporting")
    reporting_module.generate_text_report(all_results, scenario_title)
    reporting_module.generate_html_report(all_results, scenario_title)
    reporting_module.generate_pdf_report(all_results, scenario_title) # PDF !

def initialize_audit():
    """Initialise un nouveau contexte d'audit."""
    return {
        "devices": {}, # Dictionnaire pour stocker les d√©tails par IP
        "vulnerabilities": [],
        "history": [],
        "devices_found": [] # Pour la r√©tro-compatibilit√© avec les prompts
    }

def run_step(action_string, context):
    """Ex√©cute une seule √©tape d'audit et met √† jour le contexte."""
    parts = action_string.split()
    command = parts[0].lower()
    target = parts[1] if len(parts) > 1 else 'all'
    
    context['history'].append(action_string)

    # COMMANDES DE D√âCOUVERTE
    if command == "discover":
        print("\n[*] √âtape : D√©couverte g√©n√©rale des appareils...")
        discovered_devices = get_module("discover").run()
        for device in discovered_devices:
            ip = device.get('ip')
            if ip:
                context['devices'][ip] = device
        context['devices_found'] = list(context['devices'].keys())
        print(f"[+] {len(context['devices_found'])} appareils sont maintenant dans le contexte.")

    elif command == "discover_cameras":
        print("\n[*] √âtape : Recherche sp√©cifique de cam√©ras IP...")
        discovered_devices = get_module("discover").run()
        cameras = [d for d in discovered_devices if 'camera' in d.get('type', '').lower() or 'cam' in d.get('type', '').lower()]
        for device in cameras:
            ip = device.get('ip')
            if ip:
                context['devices'][ip] = device
        context['devices_found'] = list(context['devices'].keys())
        print(f"[+] {len(cameras)} cam√©ras trouv√©es.")

    elif command == "discover_routers":
        print("\n[*] √âtape : Recherche sp√©cifique de routeurs...")
        discovered_devices = get_module("discover").run()
        routers = [d for d in discovered_devices if 'router' in d.get('type', '').lower() or 'gateway' in d.get('type', '').lower()]
        for device in routers:
            ip = device.get('ip')
            if ip:
                context['devices'][ip] = device
        context['devices_found'] = list(context['devices'].keys())
        print(f"[+] {len(routers)} routeurs trouv√©s.")

    elif command == "discover_bulbs":
        print("\n[*] √âtape : Recherche d'ampoules connect√©es...")
        discovered_devices = get_module("discover").run()
        bulbs = [d for d in discovered_devices if 'bulb' in d.get('type', '').lower() or 'light' in d.get('type', '').lower()]
        for device in bulbs:
            ip = device.get('ip')
            if ip:
                context['devices'][ip] = device
        context['devices_found'] = list(context['devices'].keys())
        print(f"[+] {len(bulbs)} ampoules connect√©es trouv√©es.")

    elif command == "discover_thermostats":
        print("\n[*] √âtape : Recherche de thermostats intelligents...")
        discovered_devices = get_module("discover").run()
        thermostats = [d for d in discovered_devices if 'thermostat' in d.get('type', '').lower()]
        for device in thermostats:
            ip = device.get('ip')
            if ip:
                context['devices'][ip] = device
        context['devices_found'] = list(context['devices'].keys())
        print(f"[+] {len(thermostats)} thermostats trouv√©s.")

    elif command == "scan_wifi":
        print("\n[*] √âtape : Scan des r√©seaux WiFi...")
        # Simulation pour l'instant
        print("[+] Scan WiFi - Fonctionnalit√© en d√©veloppement")
        context['history'].append("SCAN_WIFI")

    elif command == "scan_bluetooth":
        print("\n[*] √âtape : Scan des appareils Bluetooth...")
        # Simulation pour l'instant
        print("[+] Scan Bluetooth - Fonctionnalit√© en d√©veloppement")
        context['history'].append("SCAN_BLUETOOTH")

    # COMMANDES D'ANALYSE
    elif command == "analyze":
        print(f"\n[*] √âtape : Analyse des ports pour '{target}'...")
        targets_to_scan = context['devices'].keys() if target == 'all' else [target]
        for ip in targets_to_scan:
            get_module("analyze").run(ip)

    elif command == "analyze_services":
        print(f"\n[*] √âtape : Analyse des services pour '{target}'...")
        targets_to_scan = context['devices'].keys() if target == 'all' else [target]
        for ip in targets_to_scan:
            get_module("analyze").run(ip)  # Utilise le module analyze existant

    elif command == "fingerprint":
        print(f"\n[*] √âtape : Fingerprint des appareils '{target}'...")
        targets_to_scan = context['devices'].keys() if target == 'all' else [target]
        for ip in targets_to_scan:
            get_module("analyze").run(ip)  # Utilise le module analyze existant

    elif command == "banner_grab":
        print(f"\n[*] √âtape : Extraction des banni√®res pour '{target}'...")
        targets_to_scan = context['devices'].keys() if target == 'all' else [target]
        for ip in targets_to_scan:
            get_module("analyze").run(ip)  # Utilise le module analyze existant

    # COMMANDES DE S√âCURIT√â
    elif command == "check":
        print(f"\n[*] √âtape : V√©rification des vuln√©rabilit√©s pour '{target}'...")
        targets_to_scan = context['devices'].keys() if target == 'all' else [target]
        for ip in targets_to_scan:
            results = get_module("check").run(ip)
            if results:
                context['vulnerabilities'].extend(results)

    elif command == "check_defaults":
        print(f"\n[*] √âtape : Test des mots de passe par d√©faut pour '{target}'...")
        targets_to_scan = context['devices'].keys() if target == 'all' else [target]
        for ip in targets_to_scan:
            results = get_module("check").run(ip)
            if results:
                context['vulnerabilities'].extend(results)

    elif command == "check_telnet":
        print(f"\n[*] √âtape : V√©rification des ports Telnet pour '{target}'...")
        targets_to_scan = context['devices'].keys() if target == 'all' else [target]
        for ip in targets_to_scan:
            results = get_module("check").run(ip)
            if results:
                context['vulnerabilities'].extend(results)

    elif command == "check_ssh":
        print(f"\n[*] √âtape : V√©rification des ports SSH pour '{target}'...")
        targets_to_scan = context['devices'].keys() if target == 'all' else [target]
        for ip in targets_to_scan:
            results = get_module("check").run(ip)
            if results:
                context['vulnerabilities'].extend(results)

    elif command == "check_web":
        print(f"\n[*] √âtape : Test des interfaces web pour '{target}'...")
        targets_to_scan = context['devices'].keys() if target == 'all' else [target]
        for ip in targets_to_scan:
            results = get_module("check").run(ip)
            if results:
                context['vulnerabilities'].extend(results)

    elif command == "check_config":
        print(f"\n[*] √âtape : V√©rification des configurations pour '{target}'...")
        targets_to_scan = context['devices'].keys() if target == 'all' else [target]
        for ip in targets_to_scan:
            results = get_module("check").run(ip)
            if results:
                context['vulnerabilities'].extend(results)

    # COMMANDES DE RAPPORT
    elif command == "report":
        print("\n[*] √âtape : G√©n√©ration du rapport complet...")
        get_module("reporting").generate_html_report(context['vulnerabilities'], "Audit Interactif")

    elif command == "report_html":
        print("\n[*] √âtape : G√©n√©ration du rapport HTML...")
        get_module("reporting").generate_html_report(context['vulnerabilities'], "Audit Interactif")

    elif command == "report_pdf":
        print("\n[*] √âtape : G√©n√©ration du rapport PDF...")
        get_module("reporting").generate_pdf_report(context['vulnerabilities'], "Audit Interactif")

    elif command == "export":
        print("\n[*] √âtape : Export des donn√©es...")
        # Simulation pour l'instant
        print("[+] Export des donn√©es - Fonctionnalit√© en d√©veloppement")
        context['history'].append("EXPORT")

    # COMMANDES SHODAN
    elif command == "shodan_ip":
        print("\n[*] √âtape : Analyse de votre IP publique via Shodan...")
        try:
            get_module("shodan_analyzer").analyze_public_ip()
        except:
            print("[!] Module Shodan non disponible ou cl√© API manquante")

    elif command == "shodan_similar":
        print("\n[*] √âtape : Recherche d'appareils similaires via Shodan...")
        try:
            get_module("shodan_analyzer").analyze_public_ip()
        except:
            print("[!] Module Shodan non disponible ou cl√© API manquante")

    elif command == "shodan_visibility":
        print("\n[*] √âtape : V√©rification de votre visibilit√© externe...")
        try:
            get_module("shodan_analyzer").analyze_public_ip()
        except:
            print("[!] Module Shodan non disponible ou cl√© API manquante")

    # COMMANDES IA
    elif command == "ai_analysis":
        print("\n[*] √âtape : Analyse IA des r√©sultats...")
        try:
            from core.ai_analyzer import get_ai_analysis
        except:
            from core.ai_analyzer_simple import get_ai_analysis
        analysis_prompt = f"""
        Analyse les r√©sultats de cet audit IoT :
        - Appareils trouv√©s : {len(context['devices_found'])}
        - Vuln√©rabilit√©s : {len(context['vulnerabilities'])}
        - Types d'appareils : {[d.get('type', 'Inconnu') for d in context['devices'].values()]}
        
        Donne une analyse d√©taill√©e des risques et des recommandations.
        """
        analysis = get_ai_analysis(analysis_prompt, max_length=512)
        print(f"[üß†] Analyse IA : {analysis}")

    elif command == "ai_recommendations":
        print("\n[*] √âtape : Recommandations IA...")
        try:
            from core.ai_analyzer import get_ai_analysis
        except:
            from core.ai_analyzer_simple import get_ai_analysis
        rec_prompt = f"""
        Bas√© sur cet audit IoT :
        - Appareils : {len(context['devices_found'])}
        - Vuln√©rabilit√©s : {len(context['vulnerabilities'])}
        
        Donne 3-5 recommandations prioritaires pour s√©curiser ce r√©seau IoT.
        """
        recommendations = get_ai_analysis(rec_prompt, max_length=512)
        print(f"[üß†] Recommandations IA : {recommendations}")

    elif command == "ai_risks":
        print("\n[*] √âtape : √âvaluation des risques par IA...")
        try:
            from core.ai_analyzer import get_ai_analysis
        except:
            from core.ai_analyzer_simple import get_ai_analysis
        risk_prompt = f"""
        √âvalue les risques de s√©curit√© pour ce r√©seau IoT :
        - Appareils : {len(context['devices_found'])}
        - Vuln√©rabilit√©s : {len(context['vulnerabilities'])}
        
        Donne une √©valuation des risques (Faible/Moyen/√âlev√©) avec justification.
        """
        risk_assessment = get_ai_analysis(risk_prompt, max_length=512)
        print(f"[üß†] √âvaluation des risques : {risk_assessment}")

    elif command == "unknown":
        print(f"\n[‚ùì] Je n'ai pas compris votre commande : '{action_string}'")
        print("   Tapez 'help' pour voir toutes les commandes disponibles.")
        print("   Ou reformulez votre demande en langage naturel.")
    
    else:
        print(f"[!] Commande inconnue : {command}")
        print("   Tapez 'help' pour voir toutes les commandes disponibles.")

def get_version():
    """Retourne la version actuelle de IoTBreaker"""
    return "0.1.0"

def print_banner():
    """Affiche la banni√®re IoTBreaker"""
    version = get_version()
    banner = f"""
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë                                                      ‚ïë
    ‚ïë     ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ïë
    ‚ïë     ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïë
    ‚ïë     ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó     ‚ïë
    ‚ïë     ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù     ‚ïë
    ‚ïë     ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ïë
    ‚ïë     ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù    ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïë
    ‚ïë                                                      ‚ïë
    ‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó        ‚ïë
    ‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïù        ‚ïë
    ‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù         ‚ïë
    ‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ñà‚ñà‚ïó         ‚ïë
    ‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïó        ‚ïë
    ‚ïë     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù        ‚ïë
    ‚ïë                                                      ‚ïë
    ‚ïë     Pentest IoT pour Kali Linux - v{version:<10}     ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """
    print(banner)
    print("    D√©velopp√© par: CyberS - https://github.com/servais1983/IoTBreaker\n")