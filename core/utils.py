import yaml
import sys
import os
import importlib
import logging
# Ajout de l'importation pour l'analyseur IA
from .ai_analyzer import get_ai_analysis

# Configuration du logging
logger = logging.getLogger('iotbreaker')

def log_info(message):
    """Fonction de logging pour les informations"""
    logger.info(message)
    print(f"[+] {message}")

def log_error(message):
    """Fonction de logging pour les erreurs"""
    logger.error(message)
    print(f"[!] ERREUR: {message}")

def log_warning(message):
    """Fonction de logging pour les avertissements"""
    logger.warning(message)
    print(f"[!] AVERTISSEMENT: {message}")

# Import dynamique pour √©viter les imports circulaires
def get_module(module_name):
    """Import dynamique d'un module pour √©viter les imports circulaires"""
    return importlib.import_module(f'core.{module_name}')

def run_script_yaml(path, ai_driven_mode=False):
    """
    Ex√©cute un sc√©nario de test √† partir d'un fichier YAML.
    
    En mode 'ai_driven_mode', l'IA choisit les prochaines √©tapes
    en fonction des r√©sultats obtenus.
    """
    
    # Configuration automatique de la cl√© API Shodan
    try:
        from .shodan_analyzer import set_api_key
        # Utilise uniquement les variables d'environnement pour la s√©curit√©
        shodan_key = os.getenv('SHODAN_API_KEY')
        if shodan_key:
            set_api_key(shodan_key)
            print(f"[+] Cl√© API Shodan configur√©e via variable d'environnement")
        else:
            print(f"[!] Cl√© API Shodan non trouv√©e. D√©finissez SHODAN_API_KEY dans vos variables d'environnement")
    except ImportError:
        pass
    
    if not os.path.exists(path):
        print(f"[!] ERREUR: Le fichier de sc√©nario '{path}' n'existe pas.")
        sys.exit(1)

    print(f"[*] Chargement du sc√©nario : {path}")
    try:
        with open(path, "r") as f:
            data = yaml.safe_load(f)
    except yaml.YAMLError as e:
        print(f"[!] ERREUR: Format YAML invalide: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"[!] ERREUR: Impossible de lire le fichier: {e}")
        sys.exit(1)

    # Validation du format du sc√©nario
    if not isinstance(data, dict):
        print("[!] ERREUR: Format du sc√©nario invalide. Le fichier YAML doit contenir un dictionnaire.")
        sys.exit(1)
    
    if "steps" not in data or not isinstance(data["steps"], list):
        print("[!] ERREUR: Le sc√©nario doit contenir une liste 'steps'.")
        sys.exit(1)
    
    # Affichage des informations du sc√©nario
    print(f"[+] Ex√©cution du sc√©nario: {data.get('name', 'Sans nom')}")
    if "description" in data:
        print(f"[+] Description: {data['description']}")
    
    # Configuration
    config = data.get("config", {})
    timeout = config.get("timeout", 5)
    verbose = config.get("verbose", False)
    safe_mode = config.get("safe_mode", True)
    should_exploit = config.get("exploit", False)
    if should_exploit:
        print("[!] Mode exploitation activ√©. Des actions actives seront tent√©es sur les cibles.")
    print(f"[+] Configuration: timeout={timeout}s, verbose={verbose}, safe_mode={safe_mode}")
    
    # On initialise une liste pour stocker tous les r√©sultats de l'audit
    all_results = []
    
    # Variables pour la d√©couverte automatique
    discovered_devices = []
    auto_discovery_enabled = config.get("auto_discovery", False)
    
    # ----- NOUVELLE LOGIQUE POUR LE MODE PILOT√â PAR L'IA -----
    if ai_driven_mode:
        print("[üß†] Mode d'audit pilot√© par l'IA activ√©. L'IA d√©cidera des prochaines actions.")
        
        # L'√©tat de l'audit, que nous fournirons √† l'IA
        audit_context = {
            "scenario_name": data.get('name', 'Audit Dynamique'),
            "devices_found": [],
            "vulnerabilities_found": [],
            "history": []
        }

        # On commence par une √©tape de d√©couverte, qui est toujours n√©cessaire
        print("\n[*] √âtape 1 (forc√©e): D√©couverte des appareils...")
        discovered_devices = get_module("discover").run()
        audit_context["devices_found"] = [d['ip'] for d in discovered_devices if 'ip' in d]
        audit_context["history"].append("D√©couverte r√©seau effectu√©e.")

        # Boucle d'audit dynamique pilot√©e par l'IA
        for i in range(2, 10): # On limite √† 10 √©tapes pour √©viter les boucles infinies
            prompt_ai = f"""
            Contexte de l'audit de s√©curit√© IoT en cours :
            - Sc√©nario: {audit_context['scenario_name']}
            - Appareils d√©couverts: {audit_context['devices_found']}
            - Vuln√©rabilit√©s d√©j√† trouv√©es: {audit_context['vulnerabilities_found']}
            - Historique des actions: {audit_context['history']}

            En te basant sur ce contexte, quelle est la prochaine √©tape la plus logique ? Choisis UNE seule action parmi les suivantes :
            - "ANALYZE <IP>" (pour scanner les ports d'un appareil)
            - "CHECK <IP>" (pour chercher des vuln√©rabilit√©s sur un appareil)
            - "SHODAN_LOOKUP <IP>" (pour obtenir des infos sur une IP publique)
            - "STOP" (si tu estimes que l'audit est termin√© ou qu'il n'y a plus rien de pertinent √† faire)

            R√©ponds uniquement avec l'action choisie. Par exemple : "CHECK 192.168.1.50"
            """

            print(f"\n[üß†] L'IA r√©fl√©chit √† l'√©tape {i}...")
            next_action = get_ai_analysis(prompt_ai, max_length=64)
            
            print(f"  [+] D√©cision de l'IA : {next_action}")
            audit_context["history"].append(f"D√©cision IA: {next_action}")
            
            action_parts = next_action.split()
            command = action_parts[0].lower()
            target = action_parts[1] if len(action_parts) > 1 else None

            if command == "stop":
                print("[+] L'IA a d√©cid√© de terminer l'audit.")
                break
            
            if not target:
                print("[!] L'IA n'a pas sp√©cifi√© de cible. Arr√™t de l'audit.")
                break

            # Ex√©cution de l'action choisie par l'IA
            if command == "analyze":
                get_module("analyze").run(target)
            elif command == "check":
                results_from_check = get_module("check").run(target)
                if results_from_check:
                    all_results.extend(results_from_check)
                    audit_context["vulnerabilities_found"].extend(results_from_check)
            elif command == "shodan_lookup":
                shodan_result = get_module("shodan_analyzer").get_info_for_ip(target)
                if shodan_result:
                    all_results.append(shodan_result)
            else:
                print(f"[!] Commande de l'IA inconnue : '{command}'. Arr√™t.")
                break
                
    else:
        # ----- LOGIQUE EXISTANTE POUR LE MODE SCRIPT√â -----
        print("[+] Mode d'audit script√© classique activ√©.")
        
        # Ex√©cution des √©tapes
        print("\n[*] D√©but de l'ex√©cution des √©tapes...")
        
        for i, step in enumerate(data.get("steps", []), 1):
            if not isinstance(step, dict) or "type" not in step:
                print(f"[!] AVERTISSEMENT: L'√©tape {i} est mal format√©e, ignor√©e.")
                continue
            
            step_type = step.get("type")
            target = step.get("target", "")
            description = step.get("description", "")
            
            print(f"\n[*] √âtape {i}: {step_type} {target} {description}")
            
            if step_type == "discover":
                discovered_devices = get_module("discover").run()
                if discovered_devices and auto_discovery_enabled:
                    print(f"[+] {len(discovered_devices)} appareils d√©couverts pour l'audit automatique")
            elif step_type == "analyze":
                if target == "auto_discovered" and discovered_devices:
                    # Analyse automatique de tous les appareils d√©couverts
                    analyze_module = get_module("analyze")
                    for device in discovered_devices:
                        device_ip = device.get('ip', '')
                        if device_ip:
                            print(f"[*] Analyse automatique de {device_ip}")
                            analyze_module.run(device_ip)
                elif target and target != "auto_discovered":
                    analyze_module = get_module("analyze")
                    analyze_module.run(target)
                else:
                    print("[!] AVERTISSEMENT: Aucune cible sp√©cifi√©e pour l'analyse.")
            elif step_type == "check":
                if target == "auto_discovered" and discovered_devices:
                    # V√©rification automatique de tous les appareils d√©couverts
                    check_module = get_module("check")
                    for device in discovered_devices:
                        device_ip = device.get('ip', '')
                        if device_ip:
                            print(f"[*] V√©rification automatique de {device_ip}")
                            results_from_check = check_module.run(device_ip)
                            if results_from_check:
                                all_results.extend(results_from_check)
                elif target and target != "auto_discovered":
                    check_module = get_module("check")
                    results_from_check = check_module.run(target)
                    if results_from_check:
                        all_results.extend(results_from_check)
                else:
                    print("[!] AVERTISSEMENT: Aucune cible sp√©cifi√©e pour la v√©rification.")
            elif step_type == "shodan_lookup":
                target = step.get("target")
                if not target:
                    print("[!] AVERTISSEMENT: L'√©tape shodan_lookup n√©cessite une cible 'target'.")
                    continue
                
                # Gestion de l'IP publique automatique
                if target == "auto_public_ip":
                    try:
                        import requests
                        response = requests.get('https://api.ipify.org', timeout=5)
                        target = response.text
                        print(f"[*] IP publique d√©tect√©e automatiquement: {target}")
                    except Exception as e:
                        print(f"[!] Impossible de r√©cup√©rer l'IP publique: {e}")
                        continue
                
                shodan_analyzer_module = get_module("shodan_analyzer")
                shodan_result = shodan_analyzer_module.get_info_for_ip(target)
                if shodan_result:
                    all_results.append(shodan_result)
            elif step_type == "shodan_search":
                query = step.get("query")
                limit = step.get("limit", 10)
                if not query:
                    print("[!] AVERTISSEMENT: L'√©tape shodan_search n√©cessite une requ√™te 'query'.")
                    continue
                shodan_analyzer_module = get_module("shodan_analyzer")
                shodan_analyzer_module.search_devices(query, limit)
            else:
                print(f"[!] AVERTISSEMENT: Type d'√©tape inconnu : {step_type}")
    
    print("\n[+] Ex√©cution du sc√©nario termin√©e.")
    
    # Ajout du r√©sum√© d'ex√©cution pour le reporting
    try:
        from .reporting import add_execution_summary
        add_execution_summary("Sc√©nario ex√©cut√©", data.get('name', 'Sans nom'))
        add_execution_summary("Nombre d'√©tapes", len(data.get("steps", [])))
        add_execution_summary("Vuln√©rabilit√©s trouv√©es", len(all_results))
        add_execution_summary("Mode s√©curis√©", "Activ√©" if safe_mode else "D√©sactiv√©")
        add_execution_summary("Timeout configur√©", f"{timeout} secondes")
    except ImportError:
        pass
    
    # On appelle les g√©n√©rateurs de rapport
    scenario_title = data.get('name', 'Sans nom')
    reporting_module = get_module("reporting")
    reporting_module.generate_text_report(all_results, scenario_title)
    reporting_module.generate_html_report(all_results, scenario_title)
    reporting_module.generate_pdf_report(all_results, scenario_title)

def initialize_audit():
    """Initialise un nouveau contexte d'audit."""
    return {
        "devices": {},
        "vulnerabilities": [],
        "history": [],
        "devices_found": []
    }

def run_step(action_string, context):
    """Ex√©cute une seule √©tape d'audit et met √† jour le contexte."""
    parts = action_string.split()
    command = parts[0].lower()
    target = parts[1] if len(parts) > 1 else 'all'
    
    context['history'].append(action_string)

    # COMMANDES DE D√âCOUVERTE
    if command == "discover":
        print("\n[*] √âtape : D√©couverte g√©n√©rale des appareils...")
        discovered_devices = get_module("discover").run()
        for device in discovered_devices:
            ip = device.get('ip')
            if ip:
                context['devices'][ip] = device
        context['devices_found'] = list(context['devices'].keys())
        print(f"[+] {len(context['devices_found'])} appareils sont maintenant dans le contexte.")

    elif command == "discover_cameras":
        print("\n[*] √âtape : Recherche sp√©cifique de cam√©ras IP...")
        discovered_devices = get_module("discover").run()
        cameras = [d for d in discovered_devices if 'camera' in d.get('type', '').lower() or 'cam' in d.get('type', '').lower()]
        for device in cameras:
            ip = device.get('ip')
            if ip:
                context['devices'][ip] = device
        context['devices_found'] = list(context['devices'].keys())
        print(f"[+] {len(cameras)} cam√©ras trouv√©es.")

    elif command == "discover_routers":
        print("\n[*] √âtape : Recherche sp√©cifique de routeurs...")
        discovered_devices = get_module("discover").run()
        routers = [d for d in discovered_devices if 'router' in d.get('type', '').lower() or 'gateway' in d.get('type', '').lower()]
        for device in routers:
            ip = device.get('ip')
            if ip:
                context['devices'][ip] = device
        context['devices_found'] = list(context['devices'].keys())
        print(f"[+] {len(routers)} routeurs trouv√©s.")

    # COMMANDES D'ANALYSE
    elif command == "analyze":
        print(f"\n[*] √âtape : Analyse des ports pour '{target}'...")
        targets_to_scan = context['devices'].keys() if target == 'all' else [target]
        for ip in targets_to_scan:
            get_module("analyze").run(ip)

    # COMMANDES DE S√âCURIT√â
    elif command == "check":
        print(f"\n[*] √âtape : V√©rification des vuln√©rabilit√©s pour '{target}'...")
        targets_to_scan = context['devices'].keys() if target == 'all' else [target]
        for ip in targets_to_scan:
            results = get_module("check").run(ip)
            if results:
                context['vulnerabilities'].extend(results)
        print(f"[+] {len(context['vulnerabilities'])} vuln√©rabilit√©(s) trouv√©e(s)")

    # COMMANDES DE RAPPORT
    elif command == "report":
        print("\n[*] √âtape : G√©n√©ration du rapport complet...")
        get_module("reporting").generate_html_report(context['vulnerabilities'], "Audit Interactif")

    elif command == "unknown":
        print(f"\n[‚ùì] Je n'ai pas compris votre commande : '{action_string}'")
        print("   Tapez 'help' pour voir toutes les commandes disponibles.")
        print("   Ou reformulez votre demande en langage naturel.")
    
    else:
        print(f"[!] Commande inconnue : {command}")
        print("   Tapez 'help' pour voir toutes les commandes disponibles.")

def get_version():
    """Retourne la version actuelle de IoTBreaker"""
    return "3.0.0"

def print_banner():
    """Affiche la magnifique banni√®re IoTBreaker corrig√©e"""
    version = get_version()
    banner = f"""
ü§ñ IoTBreaker - Outil d'audit de s√©curit√© conversationnel IoT
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                          ‚ïë
‚ïë  ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó      ‚ïë
‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù      ‚ïë
‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë       ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó        ‚ïë
‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë       ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù        ‚ïë
‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù   ‚ñà‚ñà‚ïë       ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó      ‚ïë
‚ïë  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù    ‚ïö‚ïê‚ïù       ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù      ‚ïë
‚ïë                                                          ‚ïë
‚ïë  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ïë
‚ïë  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ïë
‚ïë  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïë
‚ïë  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ïë
‚ïë  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïë
‚ïë  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïë
‚ïë                                                          ‚ïë
‚ïë  Outil d'audit de s√©curit√© conversationnel IoT           ‚ïë
‚ïë  Version {version:<10} - IA Conversationnelle             ‚ïë
‚ïë                                                          ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

    üîç D√©couverte intelligente    üõ°Ô∏è  Tests de s√©curit√©
    ü§ñ IA conversationnelle       üìä Rapports automatiques
    üåê Int√©gration Shodan          üéØ Exploitation √©thique
    """
    print(banner)
    print("    D√©velopp√© par: CyberS - https://github.com/servais1983/IoTBreaker\n")
